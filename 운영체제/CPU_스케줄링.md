# CPU 스케줄링

> 은빈

### CPU 스케줄링

시스템 자원을 효율적으로 사용하기 위해서는 어느 프로그램에 CPU를 넘겨줄 것인가, 그리고 얼마만큼 CPU를 점유하고 있을 것인가가 중요하다. 프로그램의 실행은 크게 두 가지로 나뉘는데, 계산 위주로 진행되는 CPU Bound Job과 사용자 인터랙션이 잦은 I/O Bound Job이 있다. 이 중, 특히 인터렉션이 잦은 I/O Bound Job에 효율적이고 적절하게 자원을 제공하기 위해 CPU 스케줄링이 필요하다.

### 필요한 경우

앞에서도 말했듯, 프로세스의 상태가 변화할 때 CPU 스케줄링이 필요하다.

- 강제 반납(preemptive)
	- Running -> Ready(Timer Interrupt)
	- Blocked -> Ready(우선순위가 높은 프로세스의 I/O 완료)
- 자진 반납(nonpreemptive)
	- Running -> Blocked(I/O 요청 등)
	- Terminate

여기서 preemptive와 nonpreemptive는 선점형/비선점형 알고리즘으로 의미가 통하기도 하는데, 선점형은 CPU가 다른 프로세스에 의해 선점당할 수 있는 것을, 비선점형은 CPU의 사용이 끝날 때까지 다른 프로세스의 영향을 받지 않는다는 것을 뜻한다. 현대의 CPU 스케줄링은 선점형 알고리즘으로 진행된다. 아마 효율성 때문이겠지?

#### 프로세스의 상태

```
                 suspended  <----------------------------------
                     |                                        |
new  -admitted->   ready  <->  running  -exit->  terminated   |
                (in memory)       |                           |
                       ^-------- blocked                      |
                                  |                           |
                              suspended  ----------------------
```

프로세스는 상태가 변경되며 수행된다. 이 상태 변경은 CPU를 사용중인지, I/O 작업이 진행중인지, 실행중인지, 끝인지 등에 따라 바뀌어진다.

- Running: 인스트럭션이 수행되고 있는 상태. CPU 선점중.
- Ready: 프로그램이 수행되기 위해 필요한 모든 것(메모리 등)은 충족됐지만 CPU 할당을 기다리는 상태.
- Blocked(wait, sleep): 프로세스가 요청한 이벤트(I/O 등)가 수행되지 않아 기다리고 있는 상태로, CPU를 선점해도 바로 인스트럭션 수행이 불가능한 상태.
	- 프로세스가 요청한 이벤트가 수행되면 Ready 상태로 변화.
- Suspended(stopped): 프로세스가 중단된 상태. 사용자의 일시 정지, 시스템 메모리 문제 등으로 중단된 상태.
	- 중단시켰던 프로세스를 resume해 주어야 활성화됨.
- New: 프로세스가 생성중인 상태.
- Terminated: 프로세스가 끝난 상태.

### CPU 스케줄링의 성능 척도
- 시스템의 입장에서: CPU 하나로 최대한 많은 일 수행하는 것이 좋은 것.
	- 전체 시간에서 CPU가 놀지 않고 일한 시간(이용률)
	- 주어진 시간 동안 몇 개의 처리를 했는지에 대한 양(처리량)
- 프로그램의 입장에서: 시간적으로 더 빨리 처리되는 것이 좋은 것.
	- CPU를 기다리는 것 부터 실행하고 끝나는 것 까지 모두 통틀어 계산한 시간(소요 시간/반환 시간)
	- ready queue에서 CPU를 기다린 시간(대기 시간)
	- CPU를 처음으로 선점하기까지 걸린 시간(응답 시간)

### CPU 스케줄링 알고리즘

#### FCFS(First Come First Served)
- 처음 도착한 프로세스부터 실행되는 알고리즘.
- 비선점형으로, 앞에 어떤 프로세스가 있느냐에 따라 전체 프로세스의 대기 시간에 영향을 끼친다.

#### SJF(Shortest Job First)
- CPU 실행 시간이 가장 짧은 프로세스부터 먼저 스케줄링하는 알고리즘.
- 비선점형과 선점형 둘 다 가능하다. 선점형의 경우 현재 점유하고 있는 프로세스보다 CPU 실행 시간이 더 짧은 프로세스에게 선점당한다. 그래서 Shortest-Remaining-Time-First(SRTF)라고 불리기도 한다.
- 선점형인 경우 평균 대기 시간의 최솟값을 보장한다.
- 하지만, CPU 사용량이 긴 프로세스는 영원히 CPU를 점유하지 못하는 기아 현상이 일어날 수 있고, CPU 사용량을 미리 알 수 없다는 점이 문제점이다.

#### Priority Scheduling
- 우선순위가 높은 프로세스부터 먼저 스케줄링하는 알고리즘.
- SJF와 동일하게 비선점형, 선점형 모두 가능하며, SJF가 우선순위 스케줄링의 일부라고 할 수 있다.
- 그래서 동일하게 기아 현상이 일어날 수 있다.
	- 그런데 우선순위의 경우, 시간이 지남에 따라 우선순위를 조금씩 늘려주면서 기아 현상을 해결할 수 있다.

#### Round Robin(RR)
- 동일한 할당 시간(time quantum, 보통 10-100ms)을 가지고 할당 시간을 모두 소진하면 다음 프로세스에게 선점당하며, ready queue의 마지막으로 들어가 다시 순서를 기다리는 방식의 스케줄링.
- 현대의 CPU 스케줄링은 해당 알고리즘에 기반하고 있다.
- 왜냐? 좋거든.. 이 알고리즘을 사용하면 프로세스의 **응답 시간**이 가장 줄어들며, CPU의 실행 시간을 예측할 필요도 없어진다.
- 물론, SJF보다 소요 시간은 더 길어질 수 있지만, 응답 시간은 덜 걸린다는 점에서 장점이다.
	- 이게 왜 장점? 각 프로세스의 입장에서 프로세스가 CPU를 선점하기까지 걸리는 시간이 줄어든다는 점, 기아 현상과 같은 위 알고리즘들의 문제점이 나타나지 않는다는 점에서 장점이 될 수 있다.


<br><br><br>

> 선경

### CPU 스케줄링

운영체제는 **스케줄링 정책**을 통해 여러 프로세스 중 CPU를 넘겨줄 프로세스를 선택한다. 스케줄링 정책은 결정을 내리기 위해 과거 정보(e.g. 직전 1분 동안 어떤 프로그램이 자주 실행되었는지), 워크로드에 관한 정보(e.g. 어떤 유형의 프로그램들이 실행되었는지), 성능 측정 결과(e.g. 단위시간당 처리량, 응답시간 등) 등을 이용한다. 

프로세스가 운영체제의 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 변경된다. 

<br>

#### 스케줄링 평가 항목
어떤 스케줄링 정책이 좋은 정책일까? 다음과 같은 평가 항목이 기준이 될 수 있다. 
- **반환 시간**: 작업이 완료된 시각 - 작업이 도착한 시각
- **응답 시간**: 작업이 처음으로 스케줄 된 시각 - 작업이 도착한 시각
- **공정성**: 모든 작업에 실행 기회를 비슷하게 분배하는지 여부

성능과 공정성은 스케줄링에서 상충된다. 

<br>

#### 스케줄링 정책의 종류

> **비선점형 스케줄러**: 실행중인 작업이 종료될 때까지 계속 실행
##### FCFS(First Come First Served)
먼저 도착한 작업을 먼저 실행한다. 단순하고 구현하기 쉬우나, CPU를 많이 필요로 하지 않는 프로세스들이 CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다려야 하는 **convoy effect**가 발생한다. 

##### SJF(Shortest Job First)
가장 짧은 실행 시간을 가진 작업을 먼저 실행한다. 모든 작업이 동시에 도착한다면 최적이나 CPU를 오랫동안 사용하는 프로세스가 먼저 도착한다면 마찬가지로 **convoy effect**가 발생한다. 

<br>

> **선점형 스케줄러**: 실행중인 작업을 중지하고 다른 작업을 실행할 수 있음 
##### STCF(Shortest Time-to-Completion First)
현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.


##### Round-Robin(RR)
하나의 작업을 일정 시간(i.e. 타임 슬라이스, 스케줄링 퀀텀) 동안 실행한 후 실행 큐의 다음 작업으로 전환한다. 이때, 타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수여야 한다. 응답 시간을 기준으로 하면 성능이 좋으나 타임 슬라이스를 너무 짧게 설정하면 문맥 교환 비용이 커지는 단점이 있다. 

##### MLFQ(Multi-level Feedback Queue)
각각 다른 우선순위가 배정된 여러 개의 큐로 구성되며 준비 상태의 프로세스는 이 중 하나의 큐에 존재한다. 각 프로세스의 우선 순위는 해당 프로세스의 실행을 관찰한 후 그에 따라 조정되는데 아래와 같은 방식으로 운용된다. 

1. 작업이 시스템에 들어가면 최상위 큐에 배치된다. 
2. 작업이 지정된 단계에서 배정받은 시간을 소진하면 작업의 우선순위는 감소한다.(한 단계 아래 큐로 이동)
3. 우선순위(A) > 우선순위(B) 일 경우, A가 실행되고 B는 실행되지 않는다. 
4. 우선순위(A) = 우선순위(B) 일 경우, A와 B는 RR 방식으로 실행된다. 
5. 일정 주기 S가 지난 후, 시스템의 모든 작업은 최상위 큐로 이동한다. 


반환 시간과 응답 시간을 모두 최적화하지만 적절한 타임 슬라이스 크기 설정, 우선순위 상향 조정 주기 등을 결정하는 데 어려움이 있다. 