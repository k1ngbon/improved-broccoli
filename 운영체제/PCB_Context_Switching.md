
# PCB(Process Control Block)와 Context Switch
 
> 은빈

### PCB(Process Control Block)이란

프로세스 제어 블록. 프로세스를 제어하는 데 필요한 정보들을 담는 자료구조이다. 프로세스의 ID, 프로세스의 상태(running, waiting 등), CPU 스케줄링 정보, 메모리, 파일 관련 등 다양한 정보를 담는다.

프로세스에 대한 정보는 왜 필요한걸까? 프로세스에 대한 정보를 읽고, 쓰는 이유는 CPU를 점유하는 프로세스가 바뀌고, 그 때마다 프로세스를 어느 정도 실행했는지, 어느 프로세스를 실행해야되는지 등에 대한 정보를 불러와야 정상적으로 실행되기 때문이다.

어? 이거 어디서 많이 봤는데... [프로세스의 문맥](https://github.com/k1ngbon/improved-broccoli/blob/main/운영체제/프로세스_스레드.md#문맥context)에서 봤듯, 프로세스의 문맥을 알아야 문맥 교환할 때 정상적으로 작동한다.

### Context Switch(문맥 교환)란

PCB가 필요한 이유. CPU가 서로 다른 프로세스에 할당될 때, 지금까지 실행되던 프로세스에 대한 정보를 PCB에 저장하고, 앞으로 실행될 프로세스에 대한 정보를 PCB에서 읽어오는 과정을 문맥 교환이라고 한다.

CPU가 프로세스간을 넘나들 때만 문맥 교환이라고 한다. 입출력으로 인해 커널이 개입된 상태일 때엔, 그냥 커널이 CPU를 가져갔다가 풀어주는 것일 뿐. Context Switch는 프로세스끼리 일어나는 일이다.

<br>

> 선경

### 문맥 교환(context switch)
시스템 콜을 통해서든 인터럽트를 통해서든 운영체제가 다시 제어권을 획득하면 이제 선택의 기로에 놓인다! 바로 어떤 프로세스를 실행할 지 결정해야 한다. 현재 프로세스를 계속 실행할 수도 있고, 다른 프로세스로 전환할 수도 있다. 이 결정은 스케줄러([관련 내용은 여기로](https://github.com/k1ngbon/improved-broccoli/blob/main/운영체제/CPU_스케줄링.md))가 하는데 만약 다른 프로세스를 실행하기로 결정했다면 **문맥 교환**을 해야한다. 

결국 **문맥 교환이란 CPU에서 현재 프로세스를 잠시 중단하고 다른 프로세스를 실행하는 것**이다. 문맥 교환을 하려면 현재 실행 중인 프로세스의 레지스터 값들을 PCB에 저장하고, 새로 실행될 프로세스의 PCB로부터 레지스터 값을 복원하면 된다. 현재 실행 중인 프로세스를 A, 새로 실행할 프로세스를 B라고 할 때, 위와 같은 교체 과정을 통해 실제로는 A에서 커널로 진입했지만, B에서 커널로 진입한 것처럼 보이게 해서 return-from-trap 명령어가 실핼될 때 운영체제가 새로 실행할 프로세스(B)로 리턴하도록 할 수 있다. 

<br>

### PCB(Process Control Block)

PCB는 프로세스의 관리를 위한 정보를 저장하는 자료구조로, 각 프로세스마다 고유한 PCB를 갖는다. 앞서 문맥 교환이 일어날 때 PCB에 레지스터 값들을 저장하고, PCB로부터 레지스터 값들을 복원한다고 언급한 바 있다. PCB에는 다음과 같은 정보들이 저장된다. 

- 프로세스 식별자(process ID)
- 프로세스 상태
- PC(프로그램 카운터): 해당 프로세스가 다음에 실행할 명령어의 주소를 가리킴
- CPU 레지스터 및 일반 레지스터
- CPU 스케줄링 정보: 우선순위, 최종 실행 시각, CPU 점유 시간 등
- 메모리 관리 정보: 해당 프로세스의 주소 공간 등
- 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
- 입출력 상태 정보: 프로세스에 할당된 I/O 장치 목록, 열린 파일 등
- 포인터: 부모/자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등