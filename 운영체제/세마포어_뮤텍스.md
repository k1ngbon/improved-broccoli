> 선경

앞서 [경쟁 조건](https://github.com/k1ngbon/improved-broccoli/blob/main/운영체제/Race_Condition.md)에 대해 배우면서 이러한 문제를 회피하려면 상호 배제를 통해 하나의 프로세스/쓰레드만이 임계 영역에 진입할 수 있도록 보장해야 한다고 배웠다. 

### 뮤텍스(락)

**뮤텍스(mutex)** 는 임계 영역을 락으로 둘러서 이를 달성하고자 한다. 하나의 쓰레드가 임계 영역에 접근하려고 할 때, 다른 어떤 쓰레드도 락을 가지고 있지 않다면 해당 쓰레드가 락을 얻어 임계 영역에 진입한다. 만약 다른 쓰레드가 이미 락을 갖고 있다면 락 획득을 시도하는 쓰레드는 락을 얻을 때까지 대기한다. 대기 상태의 쓰레드는 락을 획득할 때까지 CPU 사이클을 소모하며 회전하기 때문에 **스핀 락**으로도 불린다. 락을 획득한 함수는 임계 영역에서의 작업을 완료하면 락을 반환하고 대기 중인 쓰레드가 (있다면) 새롭게 락을 획득한다. 

<br>

### 컨디션 변수
병행성과 관련된 또 다른 문제로는 여러 쓰레드가 동시에 실행될 때 하나의 쓰레드가 제대로 실행되기 위해서는 다른 쓰레드가 작업을 완료하기까지 기다려야 하는 경우가 있다(e.g. 부모 프로세스가 자녀 프로세스의 완료를 기다리는 경우).

**컨디션 변수**는 쓰레드가 실행을 계속하기 전에 특정 조건이 만족되었는지 검사해야 할 때 사용하므로 이런 상황에 적합한 도구다. 컨디션 변수는 일종의 큐 자료구조로, 쓰레드 실행 시 어떤 조건이 원하는 상태와 일치하지 않을 때 조건이 만족되기를 대기하는 큐이다. 시그널을 대기하는 쓰레드는 수면 상태로 전환해 다른 쓰레드로부터의 시그널을 대기한다. 다른 쓰레드가 실행되어 해당 조건을 만족시키면 대기 중인 쓰레드를 깨워 마저 실행하도록 한다. 

컨디션 변수를 사용할 때 경쟁 조건의 발생을 방지하기 위해 해당 컨디션 변수와 연결된 락이 반드시 필요하다. 대기할 때, 시그널을 보낼 때 락을 거는 것이 최선이다. 


<br>

### 세마포어(semaphore)

다양한 동기화 관련 문제의 해결을 위해서는 앞에서 이야기한 락과 조건 변수가 모두 필요하다. 그래서 탄생한 것이 바로 **세마포어**다! 세마포어는 정수 값을 갖는 객체로서 두 개의 루틴으로 조작할 수 있다. 먼저 사용하기 전 값을 초기화한다. 하나의 쓰레드가 임계 영역에 접근하려고 하면 `sem_wait()` 함수를 호출해 세마포어 값을 하나 감소시키고 값이 음수인 경우 대기 큐에 넣는다. 음수가 아닌 경우 바로 리턴하고 임계 영역에 진입시킨다. 임계 영역에 진입한 쓰레드가 작업을 종료하면 `sem_post()` 함수를 호출해 세마포어 값을 증가시키고 대기 중인 쓰레드 중 하나를 깨운다. 

세마포어를 락으로 쓸 수도 있는데 락은 두 개의 상태(사용 가능, 사용 중)만 존재하므로 **이진 세마포어**라고도 불린다. 쓰레드가 두 개인 경우 세마포어의 초기값을 1로 설정하면 된다. 첫 쓰레드가 `sem_wait()`을 호출하면 세마포어의 값이 0이 되고 음수가 아니므로 임계 영역에 진입한다. 다음 쓰레드가 `sem_wait()`을 호출하면 세마포어의 값이 -1이 되므로 대기 상태에 들어간다. 쓰레드 0이 작업을 완료하면 `sem_post()` 를 호출하여 세마포어의 값이 0이 되고 잠자고 있던 쓰레드를 깨울 수 있다. 

세마포어를 컨디션 변수처럼 병행 프로그램에서 일어나는 **사건들의 순서를 정하기 위한 도구**로도 사용할 수 있다. 부모 프로세스가 자식 프로세스의 종료를 대기하는 경우가 여기에 해당한다. 세마포어 값을 0으로 초기화한 다음 부모 프로세스가 자식 프로세스 생성 후에 `sem_wait()`을 호출해 자식의 종료를 대기하게 하고, 자식은 종료 시 `sem_post()`를 호출해 시그널을 보내도록 하면 된다. 

그럼 세마포어가 어떻게 동기화 관련 문제들을 해결할 수 있을까? 생산자/소비자 문제를 통해 알아보자...

> **생산자/소비자(유한 버퍼) 문제**
> 
> 생산자 쓰레드는 데이터를 만들어 버퍼에 넣고, 소비자 쓰레드는 버퍼에서 데이터를 꺼내서 사용하며, 이러한 생산자와 소비자 쓰레드가 여럿 있다고 가정해보자. 
> 
> 이들 사이에는 커널 내부에 있는 유한 버퍼가 있는데 이는 공유 자원이기 때문에 경쟁 조건의 발생을 방지하려면 동기화가 필요하다. 
>
>상호 배제가 없는 경우 인터럽트가 발생하면 대기 중이던 소비자 프로세스가 시그널을 받는 시점, 즉 대기 상태에서 깨어나는 시점과 해당 프로세스가 실제로 실행되는 시점 사이에 시차가 있을 수 있다. 이 기간 동안 버퍼 상태가 변경되면 문제가 된다. 
>
>자고 있던 소비자가 버퍼가 찼다는 소식에 헐레벌떡 일어났는데 고 사이에 인터럽트가 발생해서 다른 소비자가 버퍼의 내용을 채갔다면? 그냥 일없이 일어난 사람이 되는 것이다... 

`empty`와 `full`이라는 두 개의 세마포어를 사용해서 이러한 문제를 해결할 수 있다. 쓰레드는 `empty`를 사용해 버퍼에 남은 공간이 있는지, `full`을 사용하여 버퍼에 읽을 내용이 담겨 있는지 표시한다. 생산자는 모든 버퍼가 차 있을 때만, 소비자는 모든 버퍼가 비어 있을 때만 대기에 들어간다. 아닌 경우 바로 각각 버퍼를 채우거나 비우는 작업을 수행한다. 이때 버퍼를 채우고 비우는 작업은 임계 영역에 해당하므로 앞뒤로 이진 세마포어를 추가해 걸어 상호 배제를 보장해야 한다. 

```c
void    *producer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&empty);
        sem_wait(&mutex);
        put(i);
        semt_post(&mutex);
        semt_post(&full);
    }
}

void    *consumer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&full);
        sem_wait(&mutex);
        int tmp = get();
        semt_post(&mutex);
        semt_post(&empty);
    }
}
```

위 코드에서 유의할 점은, 뮤텍스를 획득하고 해제하는 코드가 임계 영역 바로 이전과 이후에 있다는 점이다. 이는 교착상태를 방지하기 위해서인데 만약 뮤텍스를 획득하고 해제하는 코드가 `full`/`empty` 밖에 존재하면 버퍼 상태에 따라 대기모드로 전환할 때 뮤텍스의 반납이 불가능하기 때문이다.