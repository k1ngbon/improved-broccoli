> 선경

### 파일 시스템
메모리는 전원이 꺼지면 담겨 있던 정보가 모두 휘발되기 때문에 데이터를 영속적으로 저장하기 위해서는 다른 자원을 사용해야 한다. 하드 디스크는 영속성을 지원하는 가장 일반적인 저장 장치이다. 

**파일**은 우리가 디스크에 저장하는 데이터들을 부르는 다른 이름이다. 파일은 생성하고, 읽고, 쓰고, 삭제할 수 있는 순차적인 바이트의 배열이다. 각 파일은 **아이노드 번호(inode number)** 라고 부르는 저수준 이름을 갖고 있으며 보통은 숫자로 표현된다. 

하드 디스크에 수많은 파일들을 저장하게 되면서 이를 효율적으로 관리하기 위한 관리 시스템이 필요해졌고, 따라서 **파일 시스템**이 탄생했다. 좀 더 구체적으로 설명하면, 파일은 연속된 바이트로 이루어져 있는 반면, 디스크는 바이트 단위로 읽어들일 수 없는 구조이기 때문에 파일 시스템이 연결 작업을 해준다. 

대부분 시스템에서 운영체제는 파일의 구조를 모르는데(e.g. 어떤 파일이 그림인지, 문서인지, C언어 코드인지 아예 모른다!). 이는 파일 시스템을 통해서 손쉽게 데이터를 디스크에 안전히 저장하고, 요청할 수 있기 때문이다. 

파일 시스템은 수많은 파일들을 어떻게 관리할까? 정답 **디렉터리**가 있습니다...! 디렉터리는 <사용자가 읽을 수 있는 이름, 저수준의 이름> 쌍의 집합이며, 디렉터리의 각 항목은 파일 또는 다른 디렉터리를 가리킨다. 따라서 사용자는 모든 파일과 디렉터리들이 저장되어 있는 임의의 **디렉터리 트리** 또는 **디렉터리 계층**을 구성할 수 있다. 디렉터리는 파일 사용자 ID, 파일 형태, 크기, 저장 장소 등의 정보가 담긴 **메타 데이터**를 갖고 있기 때문에 파일 탐색을 효율적으로 할 수 있다. 

<br>

### 파일 접근 과정 
파일에 접근하기 위해 프로세스는 일반적으로 `open()` 시스템 호출을 통해 운영체제에게 권한을 요청한다. 권한이 주어지면 운영체제는 파일 디스크립터를 돌려주는데, 이를 사용하여 권한이 허용하는 읽기와 쓰기같은 접근을 처리할 수 있다. 

각 **파일 디스크립터**는 프로세스마다 존재하는 고유한 객체이며, 열린 파일 테이블(open file table)의 요소를 가리킨다. 이 요소는 가리키는 파일과 해당 파일의 현재 오프셋(파일에서 다음 번 읽고 쓸 위치가 어디인지를 나타낸다) 그리고 그 외의 관련 정보들을 담고 있다. 

`read()` 와 `write()` 를 호출하면 자연스럽게 현재 오프셋은 이동된다. 또는 프로세스가 `lseek()`를 사용하여 값을 변경할 수 있으며, 파일의 다른 부분을 접근할 수 있다. 

여러 프로세스에서 동시에 하나의 파일에 접근할 수 있기 때문에 대부분의 파일 시스템은 공유 여부를 제어하는 기법을 가지고 있다. 제어의 기초적인 형태는 **권한 비트(permission bit)** 를 통해 제공된다. 좀 더 정교한 접근 제어 목록은 정보를 조작하고 접근할 수 있는 사용자들을 좀 더 정확하게 제어할 수 있도록 한다.

<br>

### Apple File System(APFS)
iOS 10.3, macOS High Sierra부터는 파일 시스템을 기존의 HFS Plus에서 자체 Apple File System 으로 대체했다.

### 레이어 구조
APFS는 컨테이너 레이어와 파일 시스템 레이어라는 두 종류의 관념적 레이어로 구성되어 있다. **컨테이너 레이어**는 파일 시스템 레이어의 정보를 관리하고, 볼륨 메타 데이터, 볼륨 스냅샷, 암호화 상태 등의 고수준 정보를 갖고 있다. **파일 시스템 레이어**는 디렉토리 구조, 파일 메타 데이터, 파일 내용과 같은 데이터를 담고 있는 자료 구조들로 이루어져 있다. 이미 저는 이것만으로도 충분히 버거우니까...자세한 내용은 [공식 문서]((https://developer.apple.com/support/downloads/Apple-File-System-Reference.pdf))를 참고...^^

<br>


[공식 문서](https://developer.apple.com/documentation/foundation/file_system/about_apple_file_system)에 정리되어 있는 APFS의 추가적인 기능은 다음과 같으며 우리는 Foundation의 FileManager, FileHandle API를 통해 이러한 기능을 사용할 수 있다! 

#### 클론을 통한 복사 비용 감소
파일 복제 시 FileManager의 `copyItem(at:to:)`과 `copyItem(atPath:toPath:)` 메서드를 사용하면 디스크에서 별도로 공간을 차지하지 않는 복사본을 만들 수 있다. 복사본에 변경 사항이 생기면 해당 영역만 따로 디스크에 저장되고, 변경되지 않은 영역은 여전히 원본과 공유한다. 

#### 볼륨 간 빈 공간 공유
통상적인 파일 시스템의 경우 파티션마다 오직 하나의 볼륨(i.e. 파일 시스템을 사용해서 접근할 수 있는 디스크의 저장 공간)만을 지원한다. 따라서 볼륨의 크기가 고정되어 있어 용량이 한정적이다. APFS는 단일 파티션 내에서 여러 개의 볼륨을 지원하기 때문에 각 볼륨이 빈 공간을 공유하므로 공간을 효율적으로 사용할 수 있다. 

#### 드문드문한 파일의 빈 공간 할당 방지
예를 들어 3개의 블록 1, 2, 3으로 구성된 파일이 있는데 가운데의 2번 블록에만 내용이 없다면 해당 블록에는 디스크에 공간이 할당되지 않고, 1번 블록과 3번 블록만 연속적으로 할당된다. 나중에 2번 블록의 내용이 생기면 1, 3번 블록과는 다른 곳에 공간이 할당된다. 
