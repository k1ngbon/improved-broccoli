> 선경

### 세그멘테이션

메모리 가상화를 위해서는 가상 주소를 물리 주소로 변환하는 주소 변환 작업이 필요하다. 주소 변환에는 다양한 기법이 있는데 **동적 재배치**라고도 불리는 **베이스와 바운드(base-and-bound)** 는 가장 기본적인 가상화 방법이다. 프로세스마다 베이스와 바운드 레지스터를 유지해서 메모리에 접근해야할 때는 베이스 레지스터에 가상 주소를 더하고, 이렇게 생성된 주소가 바운드를 벗어나는 지 검사하면 된다! 

> 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조다. 이처럼 주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치(memory management unit, MMU)** 라고 부른다. 

하지만 동적 재배치를 사용하는 경우 프로세스 주소 공간 전체를 메모리에 올리게 되어 비효율적이다. 힙과 스택의 경우 동적으로 크기가 변하므로 힙과 스택 사이에 현재 사용 중이지 않은 잉여 공간이 존재할 수 있는데 해당 영역도 메모리를 차지하게 되기 때문... 이처럼 할당된 영역의 내부 공간이 사용되지 않는 경우 **내부 단편화**가 발생했다고 한다.

이러한 문제를 해결하기 위해 고안한 게 바로 **세그멘테이션**이다. **세그멘트(segment)** 란 특정 길이를 가지는 연속적인 주소 공간으로 코드, 스택, 힙이 각각 세그멘트에 해당한다. **세그멘테이션 방식에서는 이러한 세그멘트마다 베이스와 바운드 값이 존재**한다. 따라서 각 세그멘트를 사용 중인 메모리만큼만 물리 메모리의 각기 다른 위치에 배치할 수 있기 때문에 내부 단편화를 방지할 수 있다!

그 외에도 여러 프로그램에서 코드를 공유하는 경우 코드가 별도 세그멘트에 존재하기 때문에 해당 영역을 공유함으로써 메모리를 절약할 수 있다는 이점이 있다. 

그러나 세그멘트의 크기가 고정되어 있지 않으므로 개별 세그멘트에 메모리를 할당하고 나면 새로운 세그멘트를 할당하기에는 작은 여러 개의 빈 공간들만이 메모리에 남게 되는 **외부 단편화** 문제가 발생한다. 예를 들어 메모리에 3kb, 10k, 7kb 의 공간이 불연속적인 청크로 존재하는 경우, 크기가 15kb인 새로운 세그멘트를 위한 공간을 할당할 수 없다.

<br>

### 페이징
세그멘테이션은 메모리를 가변 크기의 조각들로 분할하기 때문에 외부 단편화 문제가 발생했다. 이를 해결하기 위해 **페이징**은 메모리를 동일 크기의 조각으로 분할한다. 주소 공간을 나눈 고정 크기 단위를 **페이지**라고 부르고, 물리 메모리도 **페이지 프레임**이라고 불리는 고정 크기의 슬롯의 배열이라고 생각해서 페이지마다 하나의 페이지를 저장하는 방식이다.

페이징에서는 페이지의 주소 변환을 위해 각 프로세스마다 **페이지 테이블**이라는 자료 구조를 유지한다. 페이지 테이블에는 **가상 페이지 번호(virtual page number, VPN)** 에 대응하는 **물리 프레임 번호(physical frame number, PFN)** 가 담겨있다. 

페이지 테이블은 매우 크기 때문에 더 이상 MMU에 담을 수 없으므로 메모리에 저장한다. 문제는 주소 변환을 위해 매번 메모리에 접근하게 되면 성능이 저하된다는 것이다. 이러한 문제를 해결하기 위해 MMU에 **TLB**라고 부르는 **주소-변환 캐시**를 도입한다. 

가상 메모리 참조 시, 먼저 TLB에 원하는 변환 정보가 있는지 확인하고, 있다면(**TLB 히트**) 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 없다면(**TLB 미스**) 페이지 테이블에 접근해 해당 정보를 TLB로 읽어들인다.

페이지 테이블 자체의 크기를 줄이려면 **멀티 레벨 페이지 테이블**을 사용할 수 있다. 페이지 테이블을 페이지 크기의 단위로 나눈 다음, 해당 페이지에 유효하지 않은 항목만 있으면 해당 페이지를 할당하지 않음으로써 사용하지 않는 주소 공간을 페이지 테이블에서 제거한다.
