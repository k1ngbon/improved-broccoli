# 프로세스와 스레드

> 은빈

### 프로세스(Process)란

컴퓨터에서 실행되고 있는 프로그램.
여기에서 중요한 것은 '실행되고 있는'이다. Xcode는 프로그램이고, 코딩을 하기 위해 Xcode 빌드를 하고 있다면 그것은 프로세스인 것.

앞서 운영체제가 하는 여러 가지 일 중에 CPU 스케줄링이 있었다. 이는 현재 실행중인 여러 개의 프로그램이 동시에 실행되고 있는 것 처럼 보이게 열심히 프로세스를 번갈아 실행하고 관리하는 것이다.

근데 운영체제가 각각 프로세스가 뭔지 알고 CPU를 할당하지? CPU를 특정 프로세스에 할당 해 주려면 프로세스에 대한 정보가 있어야 한다. 프로세스의 현재 상태를 알기 위한 모든 요소를 `문맥(context)`이라 한다.

#### 문맥(context)
- 특정 시점에서 프로세스가 어느 정도 실행 됐고, 어떤 주소공간에 어느정도의 data를 쌓아뒀는지 등을 규명하기 위한 것.
- CPU 수행 상태를 하드웨어 문맥(Program Counter, Register)
- 프로세스 주소 공간(Code, Data, Stack)
- 프로세스 관련 커널 자료구조(PCB-Process Control Block, Kernel Stack)

CPU의 열일로 프로세스들이 번갈아 실행되기 때문에 프로세스의 현재 문맥을 알고 있지 않으면 Context Switch(CPU를 어떤 프로세스에서 다른 프로세스로 넘겨 주는 과정)가 어려움!


### 스레드(Thread)란

프로세스를 수행하는 주체. CPU의 수행 단위, 프로세스에서의 실행의 흐름 단위라고도 한다. 앞서 Xcode 빌드를 하는 것 자체를 프로세스라고 하면, UI를 표시하는 작업, 서버에서 데이터를 받아오는 작업, 코드 한 블럭 블럭을 실행하는 작업 각각이 스레드인 것.

CPU 수행 단위인 만큼 각각의 스레드는 프로그램 카운터를 가진다. 프로그램 카운터만 가지는 것이 아니라, CPU가 기억하고 있어야 하는 정보(프로그램 카운터, 레지스터)를 각각 가지고 있다. 그 외에 프로세스에 대한 정보는 공유할 수 있기 때문에 공유자원으로 사용한다.

단일 스레드도 있지만 요즘은 그런거 없다. 거의(다) 멀티 스레드 환경에서 프로세스가 실행된다고 한다. 프로세스에 많은 스레드가 있으면 좋은 점이 뭘까?

1. 경제성
    - 동일한 일을 하는 스레드들이 모여 최대의 효율을 낼 수 있다.
    - CPU가 프로세스를 바꾸는 문맥 교환보다 프로세스 내에서 스레드가 교환되는 것이 오버헤드가 적다.
    - 프로세스에 대한 정보를 공유하기 때문에 자원 공유에 있어서 경제적이다.
2. 응답성
    - 다중 스레드의 경우, 하나의 스레드가 blocked 상태일 때 다른 스레드가 running되어 높은 응답성을 보일 수 있다.
3. 병렬성
    - CPU가 두 개 이상인 경우, 스레드가 병렬적으로 일을 수행할 수 있다. 

#### 프로그램 카운터(Program Counter, PC)

CPU는 한 번에 한 동작만 하지 않는다. 프로세스를 번갈아 실행시키고 입출력에 대한 처리를 하기도 하고, 커널에 대한 수행을 하기도 한다. 여기저기 돌아다니면서 열일하는데, 이 과정에서 CPU는 어느 코드까지 실행됐는지를 기억해야 한다. 그 기억이 없으면 프로세스들에게 일감을 줄 때마다(CPU를 얻는 프로세스가 바뀔 때마다) 코드를 맨 처음부터 다시 시작해야 할 것이다. CPU가 어느 코드까지 실행됐고, 어디부터 다시 실행해야 하는지를 기억하는 것이 프로그램 카운터다.


### 프로세스 vs 스레드

프로세스... 너 안에 스레드 있다...


<br><br><br>

> 선경

###  프로세스
운영체제는 CPU를 어떻게 가상화할까? 일단 하나의 프로그램을 실행한 다음 얼마 후에 중단시키고, 다른 프로그램을 실행하는 작업을 반복함으로써(i.e. **시분할**) 마치 여러 개의 CPU가 존재하는 것처럼 하나 혹은 소수의 CPU를 가상화한다. 

이때, **실행중인 프로그램을 부르는 다른 이름이 바로 프로세스**이다. 운영체제는 프로세스의 생성, 삭제 등 프로세스와 관련된 함수(i.e. 프로세스 API)들을 제공한다. 

운영체제는 여러 프로세스의 상태를 파악하고 관리하기 위해 위해 다양한 자료 구조를 유지한다. 예컨대, **레지스터 문맥 자료구조**를 통해 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장한다. 이후 해당 프로세스를 재개하게 되면 이 레지스터 값들을 복원해서 프로세스를 다시 이어서 실행한다. 자세한 내용은 문맥교환을 참고!

<br>

#### 프로세스의 하드웨어 상태
프로그램이 실행되는 동안 읽거나 갱신할 수 있는 하드웨어 상태는 다음과 같다. 
- **주소 공간**: 프로세스가 접근할 수 있는 메모리 
- **레지스터**
    - 프로그램 카운터: 프로그램의 어느 명령어가 실행 중인지 알려줌
    - 스택 포인터, 프레임 포인터: 함수의 변수와 리턴 주소를 저장하는 스택을 관리 
- **입출력 정보**: 프로세스가 현재 열어 놓은 파일 목록 

<br>

#### 프로세스 생성
그렇다면 운영체제는 어떻게 프로그램을 준비하고 실행시켜서 프로세스가 되게 할까? 
  1. 코드와 정적 데이터를 메모리에 탑재한다
  2. 스택과 힙을 생성하고 초기화한다
  3. 입출력과 관계된 초기화 작업을 수행한다
  4. 프로그램의 시작 지점에 진입하여 CPU를 새로 생성된 프로세스에게 넘긴다!
     - UIKit 에서는 앱 델리게이트에서 `@main` !

<br>

#### 프로세스 상태
프로세스의 상태는 CPU의 할당, 입출력 요청 등 특정 사건의 발생으로 인해 변화한다. 

- **실행**: CPU를 차지하고 명령어를 실핼 중
- **준비**: 실행할 준비가 되어 있으나 운영체제가 다른 프로세스를 실행하고 있어 기다리는 상태
  - 운영체제에 의해 스케줄되면 비로소 실행 상태로 넘어간다
- **대기**: 프로세스가 다른 사건(e.g. 입출력 요청)을 기다리고 있어 수행이 중단됨

<br>

### 쓰레드
쓰레드는 독립된 개체로서 프로그램 내에서 프로그램을 대신하여 일을 한다. 쓰레드는 프로세스와 매유 유사한데 프로세스와 마찬가지로 프로그램 카운터, 레지스터 등을 갖고, 문맥 교환을 통해 교체된다. 

그렇다면 굳이 쓰레드를 사용하는 이유는 뭘까?

첫째, **병렬 처리(parallelism)** 가 가능하다. 멀티 프로세서 시스템에서 프로그램을 실행하는 경우 각 프로세서마다 스레드를 사용해서 작업의 일부분을 수행하게 함으로써 실행 속도를 높일 수 있다. 

둘째, 하나의 프로세스 안에서 I/O와 다른 작업이 **중첩**될 수 있게 한다. 여러 프로그램을 대상으로 멀티프로그래밍하는 것과 같이 하나의 프로세스 안에서 쓰레드 간 전환을 통해 프로그램의 실행이 멈추지 않도록 할 수 있다.  

<br>

### 프로세스 vs 쓰레드
- **쓰레드들은 개별 스택을 갖지만 프로세스와 달리 그 외의 주소 공간은 공유**하기 때문에 한 프로세스의 모든 쓰레드들은 동일한 값에 접근할 수 있다. (그림 26.1 306쪽)
  - e.g. 2개의 쓰레드를 갖는 멀티 쓰레드 프로세스에는 스택이 2개 존재한다. 
  - 따라서 프로세스와 달리 스레드 간의 문맥 교환에서는 주소 공간을 그대로 사용한다. 

> 💡 쓰레드들이 스택을 각자 갖는 이유는 무엇일까?
>
> 쓰레드들은 각자 독립적으로 작업을 수행하므로 함수 호출 내역이 다르다. 스택은 LIFO 구조기 때문에 하나의 스택을 모든 쓰레드가 공유하면 내역을 개별적으로 관리하기 어려우므로 개별 스택을 갖는다.